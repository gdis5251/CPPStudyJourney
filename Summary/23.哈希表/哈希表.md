# 哈希表

## 哈希表的由来：

`vector`的查找时间复杂度是 O(N)，`list`的查找时间复杂度是 O(N)，甚至 `AVL树`的查找时间复杂度也不过是 O(Log2 N)。

那么有没有一种专门为查找而设计的数据结构呢？使得查找的时间复杂度能小一点。

这个时候就引入的**哈希表**。

哈希表的查找时间复杂度是 O(1)。惊讶吧！那么我就开始来介绍一下哈希表。

## 哈希表的插入方法：

在我学习 C 语言的时候，每当我需要哈希表，我就会创建一个非常大的数组，然后遇到那个数字就把那个数字对应下标的值 +1。那么这就会有一些问题：

1. 如果我要插入的数字大于我所创建的数组呢？
2. 如果我要插入负数呢？

并且这还会造成很大的资源浪费，有点得不偿失的感觉。

所以在标准库中的哈希表它是根据一个**哈希(散列)方法**来完成元素的插入的。

**刚开始哈希函数设置为：** hash(key) = key % capacity。capacity为存储元素底层空间总的大小。

举个栗子:chestnut:

数据集合 {1, 7, 6, 4, 5, 9}

根据哈希函数 **hash(key) = key % capacity    capacity = 10**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190608172955149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY3ODUwNw==,size_16,color_FFFFFF,t_70)

这看上去好像没有问题，可是如果我再插入一个 11 呢？ 1号下标的位置已经有1了呀。所以就要引出来一个哈希冲突问题。

## 哈希冲突

