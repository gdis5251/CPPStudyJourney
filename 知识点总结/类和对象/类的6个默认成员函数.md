# 类的6个默认成员函数

**如果一个类中什么成员都没有，简称空类，空类中什么都没有吗？并不是滴~任何一个类都在我们不知情的情况下生成了下面的6个默认成员函数。**

---

### 1.构造函数

**1.1 构造函数的引入**

```cpp
class Date
{
public:
	void Display()
	{
		std::cout << _year << "-" << _month << "-" << _day << std::endl;
	}

	void SetDate(int year, int month, int day)
	{
		_year = year;	//等价于this->_year = year
		_month = month;
		_day = day;
	}
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
int main()
{
	Date d1, d2;
	d1.SetDate(2018, 5, 1);
	d2.SetDate(2018, 7, 1);
	d1.Display();
	d2.Display();
	return 0;
}

```

在上面这个日期类，我们可以调用SetData函数在每次创建的时候设置信息，可是每次创建的时候都需要填入相应的参数，那么有没有一种函数在创建的时候自动填入参数呢？

**构造函数**是一个特殊的成员函数，**名字与类名相同**，创建类类型对象时，由**编译器自动调用**，保证每个数据成员都有一个合适的初始值。并且**在对象的声明周期内只调用一次。**

**1.2 特性**

**构造函数**是特殊的成员函数，虽然名字叫构造函数，但是它的任务**并不是开空间创建对象，而是初始化对象。**

**特征：**

1. 函数名与类名相同

2. 无返回值

3. 对象实例化时编译器自动调用对应的构造函数

4. 构造函数可以重载

   ```cpp
   class Date
   {
   public:
   	Date()	//无参构造函数
   	{
   		_year = 1997;
   		_month = 9;
   		_day = 21;
   	}
   
   	Date(int year, int month, int day)	//有参构造函数
   	{
   		_year = year;
   		_month = month;
   		_day = day;
   	}
   	
   private:
   	int _year; // 年
   	int _month; // 月
   	int _day; // 日
   };
   
   void Test()
   {
   	Date d;	//调用无参构造函数时，后面不需要加括号
   	Date g(1997, 9, 21); //调用有参构造函数时，需要写相应的参数值
   
   	Date d2();	//如果在创建对象时，加括号又不写参数，会被当成函数声明
   }
   
   ```

5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数。一旦用户显式定义编译器将不再生成。

   ```cpp
   class Date
   {
   public:
   	/*
   	如果用户显式定义了构造函数，编译器将不会再自动生成
   	Date()	//无参构造函数
   	{
   		_year = 1997;
   		_month = 9;
   		_day = 21;
   	}
   
   	Date(int year, int month, int day)	//有参构造函数
   	{
   		_year = year;
   		_month = month;
   		_day = day;
   	}
   	*/
   private:
   	int _year; // 年
   	int _month; // 月
   	int _day; // 日
   };
   
   void Test()
   {
   	Date d;	
   }
   ```

6. **无参的构造函数和全缺省的构造函数都被称为默认构造函数**，**并且默认构造函数只能有一个**。注意：无参构造函数、全缺省构造函数或编译器自动生成的构造函数，都可以认为是默认成员函数。

7. 编译器生成默认的构造函数会调用自定类型成员的默认成员函数。

   ```cpp
   class Time
   {
   public:
   	Time()
   	{
   		std::cout << "Time" << std::endl;
   	}
   };
   
   class Date
   {
   
   private:
   	int _a;
   	Time _t;
   };
   
   
   int main(void)
   {
       Date a;
       
       return 0;
   }
   ```

   根据我的实验：若自己在Date写一个默认构造函数，就算**不写调用自定类型的成员函数的操作**，**编译器还是会先调用自定类型的成员函数**。

8. 成员变量在命名时，要与参数有区别，一般情况下，我们都会在成员变量前或后加一个下划线。

---

### 2.析构函数

**2.1概念：**

析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。**而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。**

**2.2特性：**

1. 析构函数名是在类名前加上字符~。
2. 无参数无返回值。
3. 一个类有且仅有一个析构函数。若未显示定义，系统会自动生成默认的析构函数。
4. 对象生命周期结束时，C++编译系统自动调用析构函数。
5. 编译器自动生成的析构函数会对自定类型成员调用它的析构函数。

---

### 3.拷贝构造函数

**3.1概念：**

拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），在用已存在的类类型对象创建新对象时由编译器自动调用。

**3.2特征：**

1. 拷贝构造函数是构造函数的一种重载形式。

2. 拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用。

   > 因为在传值时，编译器在调用的时候会生成一份值拷贝，那么这个拷贝的动作又会调用拷贝构造函数，就这样无穷无尽的调用。所以在传参的时候一定要传引用。

3. 若未显示定义，系统会自动生成默认的拷贝构造函数。但是默认的拷贝构造函数对象是 按内存存储字节完成拷贝，这种拷贝我们叫浅拷贝，或者值拷贝。

   > 也就是说，如果你被拷贝的对象成员变量是指针，那么你将也拷贝的是指针,换句话说就是，你将新生成一个指针指向被拷贝对象指针的同一块区域。那么就会发生一个潜在的错误！！当你释放第一个指针指向的区域时，第二个对象在释放的时候就会引发错误，因为那块区域已经被释放掉了。

   ```cpp
   class Date
   {
   public:
   	Date()
   	{
   		_a = 1;
   		_p = &_a;
   	}
   
   
   private:
   	int _a;
   	int *_p;
   };
   
   int main(void)
   {
   	Date a;
   	Date b(a);
   	return 0;
   }
   ```

   ![TIM截图20190311164839](F:\C++\CPPStudyJourney\知识点总结\类和对象\TIM截图20190311164839.png)

---

### 4.赋值运算符重载

**4.1赋值运算符重载**

**C++为了增强代码的可读性引入了运算符重载**，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通函数类似。

函数名：关键字 **operator后面加需要重载的运算符符号。**

函数原型： **返回值类型 operator操作符（参数列表）**

注意：

- 不能通过连接其他符号来创建新的操作符：比如operator@
- 重载操作符必须有一个类类型或者枚举类型的操作数
- 用于内置类型的操作符，其含义不能改变，不能把+重载成减法操作
- 作为类成员的重载函数时，其形参看起来比操作数数目少一个成员函数的操作符有一个默认的形参this，限定为第一个参数
- *、::、sizeof、？、. 注意以上5个运算符不能重载

---

### 5 6.取地址及const取地址操作符重载

这两个默认成员函数一般不用重新定义，编译器默认会生成。

除非你不想让别人获取地址你可以重载。